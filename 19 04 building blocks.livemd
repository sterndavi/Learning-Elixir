# 19 04 2022 - coming back

## Section

```elixir
defmodule Retangule do
  def area(a, b) do
    a * b
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, Retangule, <<70, 79, 82, 49, 0, 0, 4, ...>>, {:area, 2}}
```

```elixir
Retangule.area(2, 4)
```

<!-- livebook:{"output":true} -->

```
8
```

```elixir
defmodule TestPrivate do
  def double(a) do
    sum(a, a)
  end

  defp sum(a, b) do
    a + b
  end
end

TestPrivate.double(1)
```

<!-- livebook:{"output":true} -->

```
2
```

```elixir
defmodule MyModule do
  import IO

  def my_function do
    puts("Calling imported function")
  end
end

MyModule.my_function()
```

<!-- livebook:{"output":true} -->

```
Calling imported function
```

<!-- livebook:{"output":true} -->

```
:ok
```

**2.3.6 Module attributes**

The purpose of module attributes is twofold: they can be used as compile-time constants,
and you can register any attribute, which can then be queried in runtime.

```elixir
defmodule Circle do
  @moduledoc "implements basic circle functions"
  # Defines a module attribute
  @pi 3.14159

  @moduledoc "area"
  @spec area(number) :: number
  def area(r), do: r * r * @pi

  @spec circumference(number) :: number
  @moduledoc "circumference"
  def circumference(r), do: 2 * r * @pi
end
```

<!-- livebook:{"output":true} -->

```
warning: redefining @moduledoc attribute previously set at line 2
  #cell:5: Circle (module)

warning: redefining @moduledoc attribute previously set at line 5
  #cell:10: Circle (module)

```

<!-- livebook:{"output":true} -->

```
{:module, Circle, <<70, 79, 82, 49, 0, 0, 6, ...>>, {:circumference, 1}}
```

```elixir
defmodule StringHelpers do
  @type word() :: String.t()

  @spec long_word?(word()) :: boolean()
  def long_word?(word) when is_binary(word) do
    String.length(word) > 8
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, StringHelpers, <<70, 79, 82, 49, 0, 0, 5, ...>>, {:long_word?, 1}}
```

```elixir

```
